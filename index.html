<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Connecting up Google Cardboard to web APIs</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      html, body {
        margin: 0px;
        width: 680px;
        height: 1024px;
        margin: 0 auto;
        overflow: hidden;
        background-color: #000000;
      }
    </style>
  </head>
  <body>
    <div id="top" style="height: 180px"></div>
    <div id="canvas"></div>

    <script src="./js/three.min.js"></script>
    <script src="./js/StereoEffect.js"></script>
    <script src="./js/DeviceOrientationControls.js"></script>
    <script src="./js/OrbitControls.js"></script>
    <script src="https://timezonedb.googlecode.com/files/timezonedb.js" type="text/javascript"></script>

    // shaders!
    <script id="vertexShader" type="x-shader/x-vertex">

      precision mediump float;
      precision mediump int;

      uniform mat4 modelViewMatrix; // optional
      uniform mat4 projectionMatrix; // optional

      attribute vec3 position;
      attribute vec4 color;

      varying vec3 vPosition;
      varying vec4 vColor;

      void main() {

        vPosition = position;
        vColor = color;

        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

      }

    </script>



    <script id="fragmentShader" type="x-shader/x-fragment">

      precision mediump float;
      precision mediump int;

      uniform float time;

      varying vec3 vPosition;
      varying vec4 vColor;

      void main() {

        vec4 color = vec4( vColor );
        //color.r += sin( 10.0 + time ) * 0.5;

        gl_FragColor = color;

      }

    </script>


    <script>
      var scene,
          camera, 
          renderer,
          element,
          container,
          effect,
          controls,
          clock,
          cameraMove = true,

          // Particles
          particles = new THREE.Object3D(),
          totalParticles = 20,
          maxParticleSize = 200,
          particleRotationSpeed = 0,
          particleRotationDeg = 0,
          lastColorRange = [0, 0.3],
          currentColorRange = [0, 0.3];

      var object;

      init();

      function heightField(x, y) {
        // scaled bidirectional sine function
        return Math.sin(x / 50.0) * Math.sin(y / 50.0) * 20.0;
      }

      function moveCamera() {
        cameraMove = true;
      }

      function stopCamera() {
        cameraMove = false;
      }

      function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.001, 700);
        camera.position.set(0, 15, 0);
        scene.add(camera);

        renderer = new THREE.WebGLRenderer();
        gl = renderer.context;
        gl.clearColor(0.7, 0.7, 1.0, 1.0);
        element = renderer.domElement;
        container = document.getElementById('canvas');
        container.appendChild(element);

        effect = new THREE.StereoEffect(renderer);

        // Our initial control fallback with mouse/touch events in case DeviceOrientation is not enabled
        controls = new THREE.OrbitControls(camera, element);
        camera.position.y = heightField(camera.position.x, camera.position.z) + 7.0;
        controls.target.set(
          camera.position.x + 0.15, // orbit cam about a point a little bit displaced from cam pos
          camera.position.y,
          camera.position.z
        );
        controls.noPan = true;
        controls.noZoom = true;

        // Our preferred controls via DeviceOrientation
        function setOrientationControls(e) {
          // e returns alpha, beta, gamma if valid device found
          if (!e.alpha) {
            return; // no valid tilty orientation thingy found
          }

          controls = new THREE.DeviceOrientationControls(camera, true);
          controls.connect();
          controls.update();

          element.addEventListener('mousedown', moveCamera, false);
          element.addEventListener('mouseup', stopCamera, false);

          // for some reason, setting up DeviceOrientationControls means you can remove listener
          window.removeEventListener('deviceorientation', setOrientationControls, true);
        }

        window.addEventListener('deviceorientation', setOrientationControls, true);


        /********** make rolling hill-type things **********/
        // http://gamedev.stackexchange.com/questions/78014/how-to-create-a-regular-grid-of-triangles-correctly
        // generate a 40 x 40 grid from -100 to 100 in x and z
        // so, essentially, 101 * 101 positions (thassalottapositions!)
        var geometry = new THREE.BufferGeometry();
        var vertexPositions = [];
        var res = 40.0;
        var resi = 40;

        var x = -200.0;
        var z = 200.0;
        var dx = 400.0 / res;
        var dz = 400.0 / res;
        for (var i = 0; i < resi + 1; i++) {
          for (var j = 0; j < resi + 1; j++) {
            vertexPositions.push([x + j * dx, 1.0, z - i * dz]);
          }
        }

        // a 40 x 40 grid with 2 triangles per square
        var indices = new Uint32Array(resi * resi * 6);
        var index = 0;
        for (var j = 0; j < resi; j++) {
          for (var i = 0; i < resi; i++) {
            indices[index + 0] = 0 + i + j * (resi + 1)
            indices[index + 1] = resi + 1 + i + j * (resi + 1)
            indices[index + 2] = resi + 2 + i + j * (resi + 1)

            indices[index + 3] = 0 + i + j * (resi + 1)
            indices[index + 4] = resi + 2 + i + j * (resi + 1)
            indices[index + 5] = 1 + i + j * (resi + 1)
            index += 6;
          }
        }


        var positions = new Float32Array( vertexPositions.length * 3 );
        var colors = new Float32Array( vertexPositions.length * 4 );
        //var normals = new Float32Array( vertexPositions.length * 3 );

        // components of the position vector for each vertex are stored
        // contiguously in the buffer.
        for ( var i = 0; i < vertexPositions.length; i++ )
        {
          positions[ i*3 + 0 ] = vertexPositions[i][0];
          positions[ i*3 + 1 ] = heightField(vertexPositions[i][0], vertexPositions[i][2]);//vertexPositions[i][1];
          positions[ i*3 + 2 ] = vertexPositions[i][2];

          colors[ i*4 + 0 ] = Math.random();
          colors[ i*4 + 1 ] = Math.random();
          colors[ i*4 + 2 ] = Math.random();
          colors[ i*4 + 3 ] = 1.0;


          //normals[ i*3 + 0 ] = 0.0;
          //normals[ i*3 + 1 ] = 1.0;
          //normals[ i*3 + 2 ] = 0.0;
        }

        geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
        geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
        geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 4 ) );        

        var material = new THREE.RawShaderMaterial( {

          uniforms: {
            time: { type: "f", value: 1.0 }
          },
          vertexShader: document.getElementById( 'vertexShader' ).textContent,
          fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
          side: THREE.DoubleSide,
          transparent: true

        } );

        var mesh = new THREE.Mesh( geometry, material );
        scene.add(mesh);

        object = mesh;


        clock = new THREE.Clock();

        animate();
      }

      function animate() {
        var elapsedSeconds = clock.getElapsedTime(),
            particleRotationDirection = particleRotationDeg <= 180 ? -1 : 1;

        particles.rotation.y = elapsedSeconds * particleRotationSpeed * particleRotationDirection;
        
        // We check if the color range has changed, if so, we'll change the colours
        if (lastColorRange[0] != currentColorRange[0] && lastColorRange[1] != currentColorRange[1]) {

          for (var i = 0; i < totalParticles; i++) {
            particles.children[i].material.color.setHSL(currentColorRange[0], currentColorRange[1], (Math.random() * (0.7 - 0.2) + 0.2));
          }

          lastColorRange = currentColorRange;
        }

        requestAnimationFrame(animate);

        update(clock.getDelta());
        render(clock.getDelta());
      }

      function resize() {
        var width = 680;//container.offsetWidth;
        var height = 360;//container.offsetHeight;

        camera.aspect = width / height;
        camera.updateProjectionMatrix();

        renderer.setSize(width, height);
        effect.setSize(width, height);
      }

      function update(dt) {
        resize();

        camera.updateProjectionMatrix();

        controls.update(dt);
      }

      function render(dt) {
        var time = performance.now();

        if (cameraMove) {
          var dir = camera.getWorldDirection();
          //console.log(dir);
          var dirXZ = new THREE.Vector3(dir.z, 0.0, dir.x);

          //camera.lookAt(dir + camera.position);
          dirXZ.normalize();

          //console.log(camera.position);
          //console.log(dirXZ);
          //console.log(" ");

          //camera.position.add(dirXZ);
          //camera.position.x -= dirXZ.z * 500.0 * dt; // no idea why, but world point isn't the same as cam point?
          //camera.position.z -= dirXZ.x * 500.0 * dt;
          //camera.position.y = heightField(camera.position.x, camera.position.z) + 7.0;
        }
        //object = scene.children[ 0 ];

        object.material.uniforms.time.value = time * 0.005;


        effect.render(scene, camera);
      }

    </script>
  </body>
</html>
