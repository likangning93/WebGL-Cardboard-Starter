<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Connecting up Google Cardboard to web APIs</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      html, body {
        margin: 0px;
        width: 680px;
        height: 1024px;
        margin: 0 auto;
        overflow: hidden;
        background-color: #000000;
      }
    </style>
  </head>
  <body>
    <div id="top" style="height: 180px"></div>
    <div id="canvas"></div>

    <script src="./js/three.min.js"></script>
    <script src="./js/StereoEffect.js"></script>
    <script src="./js/DeviceOrientationControls.js"></script>
    <script src="./js/OrbitControls.js"></script>
    <script src="https://timezonedb.googlecode.com/files/timezonedb.js" type="text/javascript"></script>

    <script>
      var scene,
          camera, 
          renderer,
          element,
          container,
          effect,
          controls,
          clock,

          // Particles
          particles = new THREE.Object3D(),
          totalParticles = 20,
          maxParticleSize = 200,
          particleRotationSpeed = 0,
          particleRotationDeg = 0,
          lastColorRange = [0, 0.3],
          currentColorRange = [0, 0.3];

      init();

      function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.001, 700);
        camera.position.set(0, 15, 0);
        scene.add(camera);

        renderer = new THREE.WebGLRenderer();
        gl = renderer.context;
        gl.clearColor(0.7, 0.7, 1.0, 1.0);
        element = renderer.domElement;
        container = document.getElementById('canvas');
        container.appendChild(element);

        effect = new THREE.StereoEffect(renderer);

        // Our initial control fallback with mouse/touch events in case DeviceOrientation is not enabled
        controls = new THREE.OrbitControls(camera, element);
        controls.target.set(
          camera.position.x + 0.15, // orbit cam about a point a little bit displaced from cam pos
          camera.position.y,
          camera.position.z
        );
        controls.noPan = true;
        controls.noZoom = true;

        // Our preferred controls via DeviceOrientation
        function setOrientationControls(e) {
          // e returns alpha, beta, gamma if valid device found
          if (!e.alpha) {
            return; // no valid tilty orientation thingy found
          }

          controls = new THREE.DeviceOrientationControls(camera, true);
          controls.connect();
          controls.update();

          //element.addEventListener('click', fullscreen, false); // can we change to move?

          // for some reason, setting up DeviceOrientationControls means you can remove listener
          window.removeEventListener('deviceorientation', setOrientationControls, true);
        }

        window.addEventListener('deviceorientation', setOrientationControls, true);

        // Lighting
        var light = new THREE.PointLight(0x999999, 2, 100);
        light.position.set(50, 50, 50);
        scene.add(light);

        var lightScene = new THREE.PointLight(0x999999, 2, 100);
        lightScene.position.set(0, 5, 0);
        scene.add(lightScene);

/*
        // make the floor material
        var floorTexture = THREE.ImageUtils.loadTexture('textures/wood.jpg');
        floorTexture.wrapS = THREE.RepeatWrapping;
        floorTexture.wrapT = THREE.RepeatWrapping;
        floorTexture.repeat = new THREE.Vector2(50, 50); */

        var floorMaterial = new THREE.MeshPhongMaterial({
          color: 0xdddddd,
          specular: 0xdddddd,
          shininess: 20,
          shading: THREE.FlatShading,
        });

        // make the floor geometry
        var geometry = new THREE.PlaneBufferGeometry(1000, 1000);

        var floor = new THREE.Mesh(geometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2; // three planes get placed like walls, so rotate! :P
        //scene.add(floor);

/*
        // setup particle textures
        var particleTexture = THREE.ImageUtils.loadTexture('textures/particle.png');
        var spriteMaterial = new THREE.SpriteMaterial({
            map: particleTexture,
            color: 0xffffff
          });

        // generate sprites using the sprite MTL. three js handles this all for us!
        for (var i = 0; i < totalParticles; i++) {
          var sprite = new THREE.Sprite(spriteMaterial);

          sprite.scale.set(64, 64, 1.0);
          sprite.position.set(Math.random() - 0.5, Math.abs(Math.random()), Math.random() - 0.75);
          sprite.position.setLength(maxParticleSize * Math.random());

          sprite.material.blending = THREE.AdditiveBlending;
          
          particles.add(sprite);
        }
        particles.position.y = 70;
        scene.add(particles); */
/*
        // example square using indices
        var geometry = new THREE.BufferGeometry();
        var vertexPositions = [
          [-10.0, -10.0,  0.0],
          [ 10.0, -10.0,  0.0],
          [-10.0,  10.0,  0.0],
          [ 10.0,  10.0,  0.0]
        ];

        var vertices = new Float32Array( vertexPositions.length * 3 );
        var colors = new Float32Array( vertexPositions.length * 3 );
        var normals = new Float32Array( vertexPositions.length * 3 );

        // components of the position vector for each vertex are stored
        // contiguously in the buffer.
        for ( var i = 0; i < vertexPositions.length; i++ )
        {
          vertices[ i*3 + 0 ] = vertexPositions[i][0];
          vertices[ i*3 + 1 ] = vertexPositions[i][1];
          vertices[ i*3 + 2 ] = vertexPositions[i][2];

          colors[ i*3 + 0 ] = 1.0;
          colors[ i*3 + 1 ] = 1.0;
          colors[ i*3 + 2 ] = 1.0;


          normals[ i*3 + 0 ] = 0.0;
          normals[ i*3 + 1 ] = 1.0;
          normals[ i*3 + 2 ] = 0.0;          

        }

        // can also do var indices = new Uint32Array(size);
        var indices = [0, 1, 2, 0, 2, 3,];

        geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
        geometry.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
        geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );        
        geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );

        var material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
        var mesh = new THREE.Mesh( geometry, material );
        scene.add(mesh);
*/



var triangles = 500000;

        var geometry = new THREE.BufferGeometry();

        var indices = new Uint32Array( triangles * 3 );

        for ( var i = 0; i < indices.length; i ++ ) {

          indices[ i ] = i;

        }

        var positions = new Float32Array( triangles * 3 * 3 );
        var normals = new Float32Array( triangles * 3 * 3 );
        var colors = new Float32Array( triangles * 3 * 3 );

        var color = new THREE.Color();

        var n = 800, n2 = n/2;  // triangles spread in the cube
        var d = 12, d2 = d/2; // individual triangle size

        var pA = new THREE.Vector3();
        var pB = new THREE.Vector3();
        var pC = new THREE.Vector3();

        var cb = new THREE.Vector3();
        var ab = new THREE.Vector3();

        for ( var i = 0; i < positions.length; i += 9 ) {

          // positions

          var x = Math.random() * n - n2;
          var y = Math.random() * n - n2;
          var z = Math.random() * n - n2;

          var ax = x + Math.random() * d - d2;
          var ay = y + Math.random() * d - d2;
          var az = z + Math.random() * d - d2;

          var bx = x + Math.random() * d - d2;
          var by = y + Math.random() * d - d2;
          var bz = z + Math.random() * d - d2;

          var cx = x + Math.random() * d - d2;
          var cy = y + Math.random() * d - d2;
          var cz = z + Math.random() * d - d2;

          positions[ i ]     = ax;
          positions[ i + 1 ] = ay;
          positions[ i + 2 ] = az;

          positions[ i + 3 ] = bx;
          positions[ i + 4 ] = by;
          positions[ i + 5 ] = bz;

          positions[ i + 6 ] = cx;
          positions[ i + 7 ] = cy;
          positions[ i + 8 ] = cz;

          // flat face normals

          pA.set( ax, ay, az );
          pB.set( bx, by, bz );
          pC.set( cx, cy, cz );

          cb.subVectors( pC, pB );
          ab.subVectors( pA, pB );
          cb.cross( ab );

          cb.normalize();

          var nx = cb.x;
          var ny = cb.y;
          var nz = cb.z;

          normals[ i ]     = nx;
          normals[ i + 1 ] = ny;
          normals[ i + 2 ] = nz;

          normals[ i + 3 ] = nx;
          normals[ i + 4 ] = ny;
          normals[ i + 5 ] = nz;

          normals[ i + 6 ] = nx;
          normals[ i + 7 ] = ny;
          normals[ i + 8 ] = nz;

          // colors

          var vx = ( x / n ) + 0.5;
          var vy = ( y / n ) + 0.5;
          var vz = ( z / n ) + 0.5;

          color.setRGB( vx, vy, vz );

          colors[ i ]     = color.r;
          colors[ i + 1 ] = color.g;
          colors[ i + 2 ] = color.b;

          colors[ i + 3 ] = color.r;
          colors[ i + 4 ] = color.g;
          colors[ i + 5 ] = color.b;

          colors[ i + 6 ] = color.r;
          colors[ i + 7 ] = color.g;
          colors[ i + 8 ] = color.b;

        }

        geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
        geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
        geometry.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
        geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

        geometry.computeBoundingSphere();

        var material = new THREE.MeshPhongMaterial( {
          color: 0xaaaaaa, specular: 0xffffff, shininess: 250,
          side: THREE.DoubleSide, vertexColors: THREE.VertexColors
        } );

        mesh = new THREE.Mesh( geometry, material );
        scene.add( mesh );



        clock = new THREE.Clock();

        animate();
      }

      function animate() {
        var elapsedSeconds = clock.getElapsedTime(),
            particleRotationDirection = particleRotationDeg <= 180 ? -1 : 1;

        particles.rotation.y = elapsedSeconds * particleRotationSpeed * particleRotationDirection;
        
        // We check if the color range has changed, if so, we'll change the colours
        if (lastColorRange[0] != currentColorRange[0] && lastColorRange[1] != currentColorRange[1]) {

          for (var i = 0; i < totalParticles; i++) {
            particles.children[i].material.color.setHSL(currentColorRange[0], currentColorRange[1], (Math.random() * (0.7 - 0.2) + 0.2));
          }

          lastColorRange = currentColorRange;
        }

        requestAnimationFrame(animate);

        update(clock.getDelta());
        render(clock.getDelta());
      }

      function resize() {
        var width = 680;//container.offsetWidth;
        var height = 360;//container.offsetHeight;

        camera.aspect = width / height;
        camera.updateProjectionMatrix();

        renderer.setSize(width, height);
        effect.setSize(width, height);
      }

      function update(dt) {
        resize();

        camera.updateProjectionMatrix();

        controls.update(dt);
      }

      function render(dt) {
        effect.render(scene, camera);
      }
    </script>
  </body>
</html>
