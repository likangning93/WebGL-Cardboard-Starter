<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Connecting up Google Cardboard to web APIs</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      html, body {
        margin: 0px;
        width: 680px;
        height: 1024px;
        margin: 0 auto;
        overflow: hidden;
        background-color: #000000;
      }
    </style>
  </head>
  <body>
    <div id="top" style="height: 180px"></div>
    <div id="canvas"></div>

    <script src="./js/three.min.js"></script>
    <script src="./js/StereoEffect.js"></script>
    <script src="./js/DeviceOrientationControls.js"></script>
    <script src="./js/OrbitControls.js"></script>
    <script src="https://timezonedb.googlecode.com/files/timezonedb.js" type="text/javascript"></script>

    <script>
      var scene,
          camera, 
          renderer,
          element,
          container,
          effect,
          controls,
          clock,

          // Particles
          particles = new THREE.Object3D(),
          totalParticles = 20,
          maxParticleSize = 200,
          particleRotationSpeed = 0,
          particleRotationDeg = 0,
          lastColorRange = [0, 0.3],
          currentColorRange = [0, 0.3];

      init();

      function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.001, 700);
        camera.position.set(0, 15, 0);
        scene.add(camera);

        renderer = new THREE.WebGLRenderer();
        gl = renderer.context;
        gl.clearColor(0.7, 0.7, 1.0, 1.0);
        element = renderer.domElement;
        container = document.getElementById('canvas');
        container.appendChild(element);

        effect = new THREE.StereoEffect(renderer);

        // Our initial control fallback with mouse/touch events in case DeviceOrientation is not enabled
        controls = new THREE.OrbitControls(camera, element);
        controls.target.set(
          camera.position.x + 0.15, // orbit cam about a point a little bit displaced from cam pos
          camera.position.y,
          camera.position.z
        );
        controls.noPan = true;
        controls.noZoom = true;

        // Our preferred controls via DeviceOrientation
        function setOrientationControls(e) {
          // e returns alpha, beta, gamma if valid device found
          if (!e.alpha) {
            return; // no valid tilty orientation thingy found
          }

          controls = new THREE.DeviceOrientationControls(camera, true);
          controls.connect();
          controls.update();

          //element.addEventListener('click', fullscreen, false); // can we change to move?

          // for some reason, setting up DeviceOrientationControls means you can remove listener
          window.removeEventListener('deviceorientation', setOrientationControls, true);
        }

        window.addEventListener('deviceorientation', setOrientationControls, true);

        // Lighting
        var light = new THREE.PointLight(0x999999, 2, 100);
        light.position.set(50, 50, 50);
        scene.add(light);

        var lightScene = new THREE.PointLight(0x999999, 2, 100);
        lightScene.position.set(0, 5, 0);
        scene.add(lightScene);

/*
        // make the floor material
        var floorTexture = THREE.ImageUtils.loadTexture('textures/wood.jpg');
        floorTexture.wrapS = THREE.RepeatWrapping;
        floorTexture.wrapT = THREE.RepeatWrapping;
        floorTexture.repeat = new THREE.Vector2(50, 50); */

        var floorMaterial = new THREE.MeshPhongMaterial({
          color: 0xdddddd,
          specular: 0xdddddd,
          shininess: 20,
          shading: THREE.FlatShading,
        });

        // make the floor geometry
        var geometry = new THREE.PlaneBufferGeometry(1000, 1000);

        var floor = new THREE.Mesh(geometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2; // three planes get placed like walls, so rotate! :P
        //scene.add(floor);

/*
        // setup particle textures
        var particleTexture = THREE.ImageUtils.loadTexture('textures/particle.png');
        var spriteMaterial = new THREE.SpriteMaterial({
            map: particleTexture,
            color: 0xffffff
          });

        // generate sprites using the sprite MTL. three js handles this all for us!
        for (var i = 0; i < totalParticles; i++) {
          var sprite = new THREE.Sprite(spriteMaterial);

          sprite.scale.set(64, 64, 1.0);
          sprite.position.set(Math.random() - 0.5, Math.abs(Math.random()), Math.random() - 0.75);
          sprite.position.setLength(maxParticleSize * Math.random());

          sprite.material.blending = THREE.AdditiveBlending;
          
          particles.add(sprite);
        }
        particles.position.y = 70;
        scene.add(particles); */

        // example square using indices
        var geometry = new THREE.BufferGeometry();
        var vertexPositions = [
          [ 100.0, 5.0,-100.0],
          [-100.0, 5.0,-100.0],
          [-100.0, 5.0, 100.0],        
          [ 100.0, 5.0, 100.0]
        ];

        var positions = new Float32Array( vertexPositions.length * 3 );
        var colors = new Float32Array( vertexPositions.length * 3 );
        var normals = new Float32Array( vertexPositions.length * 3 );

        // components of the position vector for each vertex are stored
        // contiguously in the buffer.
        for ( var i = 0; i < vertexPositions.length; i++ )
        {
          positions[ i*3 + 0 ] = vertexPositions[i][0];
          positions[ i*3 + 1 ] = vertexPositions[i][1];
          positions[ i*3 + 2 ] = vertexPositions[i][2];

          colors[ i*3 + 0 ] = 1.0;
          colors[ i*3 + 1 ] = 1.0;
          colors[ i*3 + 2 ] = 1.0;

          normals[ i*3 + 0 ] = 0.0;
          normals[ i*3 + 1 ] = 1.0;
          normals[ i*3 + 2 ] = 0.0;
        }

        // can also do var indices = new Uint32Array(size);
        var indices = new Uint32Array(6);
        indices[0] = 0;
        indices[1] = 1;
        indices[2] = 2;
        indices[3] = 0;
        indices[4] = 2;
        indices[5] = 3;

        geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
        geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
        geometry.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
        geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );        

        var material = new THREE.MeshPhongMaterial( {
          color: 0xaaaaaa, specular: 0xffffff, shininess: 250,
          side: THREE.DoubleSide, vertexColors: THREE.VertexColors
        } );

        var mesh = new THREE.Mesh( geometry, material );
        scene.add(mesh);


        clock = new THREE.Clock();

        animate();
      }

      function animate() {
        var elapsedSeconds = clock.getElapsedTime(),
            particleRotationDirection = particleRotationDeg <= 180 ? -1 : 1;

        particles.rotation.y = elapsedSeconds * particleRotationSpeed * particleRotationDirection;
        
        // We check if the color range has changed, if so, we'll change the colours
        if (lastColorRange[0] != currentColorRange[0] && lastColorRange[1] != currentColorRange[1]) {

          for (var i = 0; i < totalParticles; i++) {
            particles.children[i].material.color.setHSL(currentColorRange[0], currentColorRange[1], (Math.random() * (0.7 - 0.2) + 0.2));
          }

          lastColorRange = currentColorRange;
        }

        requestAnimationFrame(animate);

        update(clock.getDelta());
        render(clock.getDelta());
      }

      function resize() {
        var width = 680;//container.offsetWidth;
        var height = 360;//container.offsetHeight;

        camera.aspect = width / height;
        camera.updateProjectionMatrix();

        renderer.setSize(width, height);
        effect.setSize(width, height);
      }

      function update(dt) {
        resize();

        camera.updateProjectionMatrix();

        controls.update(dt);
      }

      function render(dt) {
        effect.render(scene, camera);
      }
    </script>
  </body>
</html>
